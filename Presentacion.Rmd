---
title: "Modelos de TRI para<br>cuestionarios de elección forzosa"
author: "Daniel Morillo"
date: "`r format(lubridate::today(), '%d de %B de %Y')`"
output:
  revealjs::revealjs_presentation:
    transition: slide
    transitionSpeed: slow
    theme: white
    incremental: true
    center: false
    slide_level: 1
    maxScale: 0.6
    fig_width: 6
    fig_height: 4
    fig_caption: false
    self_contained: false
    reveal_plugins: ["notes"]
bibliography: "res/dissertation_bibliography.bib"
csl: "res/apa-old-doi-prefix.csl"
editor_options:
  chunk_output_type: console
---


```{r setup, include=FALSE, cache=FALSE}

library(tidyverse)
library(magrittr)
library(knitr)
library(gridExtra)

"R/Rmarkdown_code.R" %>% source(encoding = 'UTF-8')

opts_chunk$set(
  cache = FALSE, results = 'asis',
  message = FALSE, warning = FALSE, echo = FALSE
)

init_ggplot()

"R/Presentacion.R" %>% readLines(encoding = 'UTF-8') %>% read_chunk(lines = .)

```


# {data-background-image="res/LOGO_UAM_NEGRO_VARIANTE.jpg" data-background-position='5% 4%' data-background-size='10% auto' data-background-transition='slide'}

```{css styles}

reveal p {
  text-align: left;
}

.reveal ul {
  display: block;
}

.container{
    display: flex;
}

.col{
    flex: 1;
}

```


```{r title}

h2("Modelos de Teoría de Respuesta al Ítem para cuestionarios de elección forzosa")
h4("Tesis doctoral enviada para la obtención del título de Doctor en Psicología Clínica y de la Salud")

br()

p("Por: Daniel Morillo")
p("Supervisores: Francisco José Abad, Iwin Leenen")
p("Tutor: Vicente Ponsoda")

lubridate::today() %>% format('%d de %B de %Y') %>% p

```


<aside class="notes">

Buenos días.
Ante todo muchas gracias a los miembros del tribunal por acceder a evaluar el
trabajo de mi tesis doctoral, así como al público por estar aquí y darme la
oportunidad de exponer públicamente los resultados de mi investigación
predoctoral.

Mi nombre es Daniel Morillo, y el título de mi proyecto de tesis es
Vamos a comenzar haciendo una breve introducción para establecer el contexto
teórico.

</aside>


---

```{r intro_title_slide}

main_layout("Introducción:", "Marco teórico")

```


# El formato de Elección Forzosa multidimensional

- Formato de respuesta

- Evaluación no cognitiva

- Control de sesgos de respuesta

- Puntuaciones ipsativas [@cattell_psychological_1944]


<aside class="notes">

El formato EF multidimensional se utiliza cada vez más, la industria demanda
aplicaciones del mismo, principalmente con el objetivo de controlar los sesgos
de respuesta en cuestionarios para la medición de rasgos no cognitivos, con el
objeto de controlar los sesgos de respuseta, y por tanto aumentar su validez.

</aside>


# Ipsatividad

<br>

- Estructura del espacio latente distorsionada [@clemans_analytical_1966]:

- Fiabilidad reducida [@hicks_properties_1970]

- Validez predictiva distorsionada

- Puntuaciones intra-persona


<aside class="notes">

Las puntuaciones de estos instrumentos serían intra-persona, es decir,
permitirían comparar diferentes niveles en diferentes rasgos para una misma
persona, pero no permitirían comparar el mismo rasgo entre diferentes personas

</aside>


# Justificación {data-transition="slide-in fade-out"}

</br>
<center>Aplicación de la Teoría de Respuesta al Ítem</center>

</br>

- Desarrollo y aplicación del modelo MUPP-2PL

    - Propuesta de método de estimación

    - Aplicación a bloques EF de ítems emparejados
    
    - Abordaje teórico de sus propiedades

- Basado en el modelo MUPP [@stark_irt_2005]


<aside class="notes">

El objetivo de esta tesis es proponer y estudiar las propiedades de un modelo
de teoría de respuesta al ítem, con el objeto de solucionar los problemas de
derivados de la ipsatividad de las puntuaciones en cuestionarios de EF
multidimensionales.

Está basado en el modelo MUPP, propuesto originalmente por Stark, Chernyshenko y
Drasgow. Este modelo ya ha sido planteado anteriormente para solucionar los
problemas de ipsatividad de este tipo de instrumentos.

</aside>


# Justificación {data-transition="fade-in slide-out"}

</br>
<center>Aplicación de la Teoría de Respuesta al Ítem</center>

</br>

- Supuesto de independencia MUPP [@stark_irt_2005]:

</br>

<div class="fragment" style="align:center">
<small>
$$
\textrm{P}_i \left(Y_{ij} = 1 \right) = \frac{\textrm{P}_i \left(X_{i_1j} = 1 \right) \textrm{P}_i \left(X_{i_2j} = 0 \right)}{\textrm{P}_i \left(X_{i_1j} = 1 \right) \textrm{P}_i \left(X_{i_2j} = 0 \right) + \textrm{P}_i \left(X_{i_1j} = 0 \right) \textrm{P}_i \left(X_{i_2j} = 1 \right)}
$$
</small>
</div>

</br>

- Supuesto de _dominancia_: modelo logístico de 2 parámetros
[@birnbaum_latent_1968]

<aside class="notes">

El modelo se basa en el supuesto de que la persona evaluada toma
la decisión de acuerdo o desacuerdo con cada una de las dos opciones de
respuesta de manera independiente.

Sin embargo, el modelo MUPP original está basado en un modelo de medida de punto
ideal, con una formulación compleja y gran número de parámetros, mientras que
nuestra propuesta asume un modelo de medida de dominancia, que supone que la
probabilidad de acuerdo con cada una de las dos opciones sigue un modelo
logístico de dos parámetros.

</aside>


# Modelo MUPP-2PL

<center>Supuesto de medida: 2PL [@birnbaum_latent_1968]</center>

</br>

<div class="container">
  <div class="col">
  
  <small>
    
$$
\textrm{P}_i \left(X_{ij} = 1 | \theta_j \right) = \Phi_L \left(a_i\theta_j + b_i \right)
$$
  </small>
  </div>
  
  <div class="col">
  
```{r 2PL, fig.width=4, fig.height=3.5, cache=FALSE}

theta_vector <- seq(-3, 3, 0.1)

probs <- irf_2PL(theta_vector, 1.8, 0)

irf <- tibble(
  theta = theta_vector,
  prob  = probs,
  lab   = paste0(
    "P<sub>i</sub>(", theta %>% format(digits = 1), ") = ", prob %>% round(3)
  )
)

irf_plot <- irf %>% ggplot(
  mapping = aes(x = theta, y = prob, text = lab, group = NA)
) + geom_path(color = "darkblue", size = 1) +
  ggtitle("Curva característica del ítem") +
  scale_x_continuous(expand = expand_scale()) +
  scale_y_continuous(expand = expand_scale(.01))

irf_plot %>% ggplotly(tooltip = "text") %>%
  plotly::layout(
    xaxis = list(title = TeX("\\textrm{P}_i \\left(X_{ij} = 1 | \\theta_j \\right)")),
    yaxis = list(title = TeX("\\theta_j"))
  ) %>% plotly_conf

```
  </div>
</div>


<aside class="notes">

Este modelo es más simple y con más desarrollos teóricos previos que el modelo
de medida de punto ideal, lo que permite formular un modelo más parsimonioso,
más sencillo de abordar teóricamente, y con un mayor soporte teórico en el
ámbito de la medición de rasgos de personalidad.

</aside>


# Estructura

<br>

- Estudio 1: Propuesta del modelo MUPP-2PL y algoritmo de estimación

- Estudio 2: Estudio y evaluación de la sensibilidad dimensional

- Estudio 3: Comprobación del supuesto de invarianza

- Conclusions


<aside class="notes">

Conclusiones en inglés

</aside>


---

```{r study_1_title_slide}

main_layout(
  "Estudio 1:",
  "Propuesta del modelo MUPP-2PL y algoritmo de estimación"
)

```


# Objetivos

</br>

- Propuesta teórica del modelo

- Desarrollo de algoritmo de estimación Bayesiana conjunta
(Markov Chain-Monte Carlo)

- Comparación con estimación factorial


<aside class="notes">

El objetivo del estudio 1 es estudiar las propiedades teóricas del modelo, así
como la estimación del mismo mediante el método Bayesiano propuesto.

Asimismo, como existe una equivalencia práctica entre el modelo MUPP-2PL
y el modelo TIRT como veremos, esto nos permite comparar los dos métodos de
estimación, el Bayesiano planteado en este capítulo, basado en información
completa, y el método frecuentista, basado en Análisis Factorial Confirmatorio
de la información bivariada.

Por lo tant, se han puesto a prueba ambos métodos de estimación en un estudio de
simulación y en datos empíricos para comprobar cómo afectan las condiciones
(sobre todo las supuestamente desfavorables según la literatura previa)

</aside>


# Equivalencia entre modelos

</br>
<div class="fragment">
$$
\textrm{P}_i\left(Y_{ij} = 1 | {\bf \unicode[Times]{x3B8}}\right) = \Phi_L\left(a_{i_1}\theta_{\tilde{i_1}j} - a_{i_2}\theta_{\tilde{i_2}j} + l_i\right)
$$
</div>

- Modelo Logístico Multidimensional Compensatorio

- Thurstonian IRT model:

<div class="fragment">
$$
\textrm{P}_i\left(Y_{ij} = 1 | {\bf \unicode[Times]{x3B8}}\right) = \Phi_N\left(a_{i_1}\theta_{\tilde{i_1}j} - a_{i_2}\theta_{\tilde{i_2}j} + l_i\right)
$$
</div>


<aside class = "notes">

El modelo propuesto es algebraicamente equivalente a un modelo logístico
multidimensional compensatorio, una propiedad muy útil para estudiar
posteriormente algunas de sus propiedades desde un punto de vista teórico

Asimismo, hay una cuasi-equivalencia con el modelo TIRT, que se diferencia
únciamente por la función de enlace, que es la función de probabilidad acumulada
en lugar de la función logística.

</aside>


# Estimación Bayesiana

</br>

- Algoritmo Markov Chain-Monte Carlo

- Información completa (vs. bivariada)

- Estimación conjunta

- Muestreo Metropolis-within-Gibbs adaptativo

- Estadísticos "Expected a Posteriori"


<aside class="notes">

La estimación Bayesiana ha sido implementada en un algoritmo Markov-Chain
Monte Carlo para muestrear la distribución posterior.
Este algoritmo utiliza la información completa de los vectores de respuesta,
lo que previsiblemente dará lugar a una mejor recuperación del espacio latente.

Además, gracias a que se estima la distribución conjunta de los parámetros
estructurales e incidentales, esperamos una mayor precisión en la estimación de
la incertidumbre de los parámetros incidentales respecto a los procedimientos
que estiman los parámetros estructurales y después dan sus valores como
conocidos, utilizando los estimadores puntuales, para estimar los parámetros
incidentales.

Sin profundizar en los detalles técnicos, hemos aplicado un muestreados de Gibbs
con un paso Metropolis por cada tipo de parámetro.  Esto permite reducir la
dimensionalidad de cada paso mejorando la convergencia.
También para mejorar la convergencia el muestreo se ha implementado mediante un
algoritmo de adaptativo de la tasa de aceptación.

Para obtener los estimadores puntuales hemos utilizado el estadístico EAP de la
distribución posterior, que se puede calcular de manera muy sencilla una vez
se han generado las muestras y comprobado los criterios de calidad.

</aside>

```{r simulation_recovery_result_matrix}
```

# Estudio de simulación

</br>

- Estimación sin bloques unidimensionales:

<div class="fragment">
> It is currently believed that unidimensional pairings are needed to identify
> the metric so that scores on different dimensions can be estimated and
> compared in a meaningful way [@chernyshenko_normative_2009].

</div>

- Comparación con estimación basada en CFA


<aside class="notes">

Interés en poner a prueba la estimación en condiciones supuestamente
desfavorables.

Por un lado, se argumenta la necesidad de utilizar bloques unidimensionales para
identificar la métrica, pero esta afirmación no está teóricamente justificada.
Puesto que el MUPP-2PL no parece plantear problemas de identificación, su
aplicación práctica es limitada, e implica complicaciones adicionales, obviamos
la inclusión de bloques unidimensionales, en previsión de que serían
innecesarios.

Los resultados de las simulaciones así lo demuestran, permitiendo estimar los
parámetros del modelo de forma precisa, tanto con el algoritmo MCMC como con
análisis factorial confirmatorio.

</aside>


# Estudio de simulación

<center>Resultados: Rasgo latente (incertidumbre)</center>

</br>

<center>
```{r simulation_recovery_results_lt_CrI, fig.align='center', dependson="simulation_recovery_result_matrix", cache=FALSE}

lt_CrI_plots <- study_1_results %>%
  filter(Parametro == "Rasgo latente", Variable == "QL") %>%
  mutate(Valor = Valor * 100) %>%
  rename(`Longitud cuestionario (nº ítems)` = Nivel) %>%
  ggplot(
    aes(
      `Longitud cuestionario (nº ítems)`, Valor,
      group = Algoritmo, color = Algoritmo
    )
  ) + geom_point(alpha = .5) + geom_line(alpha = .75) + ylim(c(90, 100)) +
  ylab("% cobertura del parámetro verdadero") +
  ggtitle("Intervalo de credibilidad del rasgo latente")
  

lt_CrI_plots %>% ggplotly(tooltip = c("y", "colour")) %>% plotly_conf

```
</center>

<aside class="notes">

Por otro lado, debido a la estimación conjunta, la incertidumbre en la
estimación de los parámetros incidentales, operativizada como el porcentaje de
cobertura de los intervalos de credibilidad, es más precisa con el algoritmo
MCMC.

El análisis factorial confirmatorio sin embargo infraestima la incertidumbre de
los parámetros incidentales, y además se ve afectado por algunas condiciones de
estimación, como el número de bloques.

</aside>


# Estudio de simulación

</br>

- Estimación sólo con bloques homopolares

<div class="fragment" style="align:left">
> [...] in a forced-choice application with five traits, the design with 30
> positively keyed item pairs would fall slightly short of the measurement
> precision that is typically required. However, the questionnaire can be
> sufficiently precise when both positive and negative items are combined in
> blocks [@brown_item_2011].

</div>

<aside class="notes">

Por otro, nos interesa evaluar la necesidad de incluir bloques heteropolares,
dados los problemas metodológicos que conllevaría ese diseño en la medida en
contextos de altas consecuencias, donde es necesario controlar los sesgos, ya
que en la literatura se ha argumentado que es necesario incluirlos siempre para
evitar problemas de convergencia en la estimación.

</aside>


# Estudio de simulación

<center>Resultados: Parámetros de correlación</center>

</br>

<center>
```{r simulation_recovery_results_correlations, fig.align='center', dependson="simulation_recovery_result_matrix", cache=FALSE}

corrs_RMSE_plot <- study_1_results %>% filter(Parametro == "Correlaciones") %>%
  mutate(Nivel = Nivel %>% factor(levels = levels(.) %>% rev)) %>%
  rename(RMSE = Valor, `Proporción de bloques heteropolares` = Nivel) %>%
  ggplot(
    aes(
      `Proporción de bloques heteropolares`, RMSE,
      group = Algoritmo, color = Algoritmo
    )
  ) +
  geom_point() + geom_line() + ylim(c(0, .1)) +
  ggtitle("Correlaciones entre dimensiones latentes")

corrs_RMSE_plot %>% ggplotly(tooltip = c("y", "colour")) %>% plotly_conf

```
</center>


<aside class="notes">

Los resultados muestran que la estructura del espacio latente se estima con
mayor error cuando sólo hay bloques homopolares, pero el algoritmo MCMC pierde
menos precisión.
Presumiblemente, esto sería debido a la estimación conjunta de parámetros
estructurales e incidentales, a las propiedades de la estimación Bayesiana, o a
ambas.

</aside>


# Estudio de simulación

Resultados: Rasgo latente (precisión)

</br>

<center>
```{r simulation_recovery_results_lt_prec, fig.align='center', dependson="simulation_recovery_result_matrix", cache=FALSE}

lt_rel_plots <- study_1_results %>%
  filter(
    Parametro == "Rasgo latente", Variable == "OPBP",
    Estadistico == "Fiabilidad"
  ) %>%
  mutate(Nivel = Nivel %>% factor(levels = levels(.) %>% rev)) %>%
  rename(`Proporción de bloques heteropolares` = Nivel) %>%
  ggplot(
    aes(
      `Proporción de bloques heteropolares`, Valor,
      group = Algoritmo, color = Algoritmo
    )
  ) +
  geom_point(alpha = .5) + geom_line(alpha = .5) + ylab("") + ylim(0:1) +
  ggtitle("Niveles de rasgo latente")

lt_rel_plots %>% ggplotly(tooltip = c("y", "colour")) %>% plotly_conf

```
</center>


<aside class="notes">

Además vemos que la fiabilidad decrece cuando sólo hay bloques homopolares.
Sin embargo, el algoritmo MCMC arroja fiabilidades ligeramente superiores, que
estarían dentro de los márgenes aceptables.

</aside>


# Estudio empírico

```{r empirical_reliabilities}
```

</br>

- Mejor convergencia de estimaciones

- Fiabilidades mayores

<div class="fragment">
<center>
```{r empirical_reliabilities_plot, dependson="empirical_reliabilities", fig.height=3.5}

emp_rels %>% plot_ly(
  r = ~Fiabilidad, split = ~`Método`, theta = ~Rasgo,
  type = "scatterpolar",
  mode = "markers",
  fill = 'toself',
  hovertext = ~Fiabilidad,
  hoverinfo = "text"
) %>% plotly_conf() %>% layout(
  polar = list(radialaxis = list(visible = TRUE, range = 0:1)),
  magin = list(t = 40)
)

```
</center>
</div>


<aside class="notes">

Esto también queda ilustrado en la aplicación a datos empíricos en un
cuestionario de Elección Forzosa de personalidad para el Modelo Big Five,
donde encontramos mayores fiabilidades con el algoritmo MCMC.

Aparte de una mejor convergencia de los parámetros estructurales cuando la
información empírica es escasa.

</aside>


# Discusión

</br>

- Equivalencia modelo MUPP-2PL y otros modelos

- Mejores resultados del algoritmo MCMC en algunos parámetros

- Estimable sin bloques unidimensionales

- Estimable sin bloques heteropolares


<aside class="notes">

El modelo MUPP-2PL es algebraicamente equivalente al modelo Multidimensional
Logístico Compensatorio, lo que permite establecer analogías y generalizar
resultados, y al modelo TIRT aplicado a pares, permitiendo comparar métodos de
estimación y hacer generalizaciones.

En cuanto a la estimación, vemos que el algoritmo MCMC da mejores resultados en
algunos indicadores de recuperación de parámetros. También, que es posible
estimar el modelo MUPP-2PL sin bloques unidimensionales y sin bloques
heteropolares.

</aside>


---

```{r study_2_title_slide}

main_layout(
  "Estudio 2:",
  "Estudio y evaluación de la sensibilidad dimensional"
)

```


<aside class="notes">

En lo que a los bloques heteropolares se refiere, encontramos por lo tanto una
discrepancia entre nuestros resultados y los encontrados por Brown y
Maydeu-Olivares en su artículo de 2011.

</aside>


# Introducción

</br>

<div class="container">
  
  <div class="col fragment">
```{r MUPP_2PL_sparse_directions, cache=FALSE, fig.width=3, fig.height=3.2, fig.align='center'}

set.seed(345654)

N_BLOCKS <- 18
SCALE_CORR_1 <- -.6
SCALE_CORR_2 <- .85
LOCATION_PARAMS <- rnorm(N_BLOCKS, 0, .5)

scales <- rbvlnorm(
  N_BLOCKS, location = c(.25, .25),
  bvlnorm.scale(c(.25, .25), SCALE_CORR_1)
)
tibble(
  a1 = scales[, 1], a2 = scales[, 2], l = LOCATION_PARAMS,
  pol1 = "+", pol2 = "+", dim1 = "theta_1", dim2 = "theta_2"
) %>% plot_MUPP_2PL_vectors(cor = 0, alpha = .75, thickness = 1)

```
  </div>

  <div class="col fragment">
```{r MUPP_2PL_empirical_underidentification, cache=FALSE, fig.width=3, fig.height=3.2, fig.align='center', dependson="MUPP_2PL_sparse_directions"}

scales <- rbvlnorm(
  N_BLOCKS, location = c(.25, .25),
  bvlnorm.scale(c(.25, .25), SCALE_CORR_2)
)
tibble(
  a1 = scales[, 1], a2 = scales[, 2], l = LOCATION_PARAMS,
  pol1 = "+", pol2 = "+", dim1 = "theta_1", dim2 = "theta_2"
) %>% plot_MUPP_2PL_vectors(cor = 0, alpha = .75, thickness = 1)

```
  </div>

  <div class="col fragment">
```{r MUPP_2PL_heteropolar_blocks, cache=FALSE, fig.width=3, fig.height=3.2, fig.align='center', dependson="MUPP_2PL_empirical_underidentification"}

tibble(
  a1 = scales[, 1], a2 = scales[, 2], l = LOCATION_PARAMS,
  pol1 = c("+" %>% rep(N_BLOCKS / 3), "-" %>% rep(N_BLOCKS / 3), "+" %>% rep(N_BLOCKS / 3)),
  pol2 = c("+" %>% rep(N_BLOCKS * 2 / 3), "-" %>% rep(N_BLOCKS / 3)),
  dim1 = "theta_1", dim2 = "theta_2"
) %>% plot_MUPP_2PL_vectors(
    cor = 0, alpha = .75, thickness = 1, colors = .$pol1 != .$pol2
  )

```
  </div>
  
</div>


<aside class="notes">

Los desarrollos teóricos del Capítulo 3, plasmados en los dos teoremas, dan a
entender que esto se debe al problema que denominamos restricción dimensional,
que ocurre cuando sólo tenemos bloques homopolares.

En estos casos, corremos el riesgo de que la dirección de medida sea muy similar
en todos los bloques, siendo el cuestionario prácticamente unidimensional, cosa
que no puede ocurrir en presencia de bloques heteropolares.

</aside>


# Introducción

</br>

<center>
```{r MUPP-2PL_underidentification_3D, cache=FALSE, fig.align='center', dependson="MUPP_2PL_heteropolar_blocks", fig.width=8, fig.height=6}

SCALE_CORR_3 <- .95

scales <- rbvlnorm(
  N_BLOCKS, location = c(.25, .25),
  bvlnorm.scale(c(.25, .25), SCALE_CORR_3)
)

underidentified_scales_3D <- tibble(
  a1 = scales[, 1], a2 = scales[, 2], l = LOCATION_PARAMS,
  pol1 = "+", pol2 = "+",
  dim1 = c("theta_1" %>% rep(N_BLOCKS * 2 / 3), "theta_2" %>% rep(N_BLOCKS / 3)),
  dim2 = c("theta_2" %>% rep(N_BLOCKS / 3), "theta_3" %>% rep(N_BLOCKS * 2 / 3))
)

MCLM_blocks <- underidentified_scales_3D %>% MUPP2PL_to_MCLM
multidim_blocks <- underidentified_scales_3D %>%
  multidim_params_MUPP_2PL(diag(3))

origin_coords <- multidim_blocks %>%
  transmute_at(vars(starts_with("theta")), "*", .$MBL) %>%
  rename_all(str_replace, pattern = "theta", replacement = "coord") %>%
  rowid_to_column(var = "Item") %>% mutate(Point = "origin")

end_coords <- multidim_blocks %>%
  transmute_at(vars(starts_with("theta")), "*", (.$MBL + .$MBS)) %>%
  rename_all(str_replace, pattern = "theta", replacement = "coord") %>%
  rowid_to_column(var = "Item") %>% mutate(Point = "end")

segment_coords <- bind_rows(origin_coords, end_coords)

tip_coords <- bind_cols(
  end_coords,
  multidim_blocks %>% select(starts_with("theta"))
)

segment_coords %>% plot_ly(
  type= "scatter3d", mode = "lines",
  x = ~coord_1, y = ~coord_2, z = ~coord_3,
  split = ~Item, hoverinfo = "none", color = I(PALETTE.COLORS[4])
) %>%
  add_trace(
    type = "cone", data = tip_coords,
    x = ~coord_1, y = ~coord_2, z = ~coord_3,
    u = ~theta_1, v = ~theta_2, w = ~theta_3,
    hoverinfo = "none", color = I(PALETTE.COLORS[2]),
    showscale = FALSE
  ) %>%
  layout(
    scene = list(
      aspectmode = "cube",
      xaxis = list(title = HTML("\u03B81")),
      yaxis = list(title = HTML("\u03B82")),
      zaxis = list(title = HTML("\u03B83"))
    ),
    showlegend = FALSE
  )
      
```
</center>


<aside class="notes">

Cuando el cuestionario de elección forzosa mide tres dimensiones latentes,
es más difícil visualizar el problema, pero podemos ver que los bloques tienden
a concentrarse en un único plano.

Y con más de tres dimensiones es imposible representarlo, pero básicamente si el
cuestionario está diseñado para medir D dimensiones, en condiciones de
restricción dimensional solamente puede obtener D-1 parámetros de rasgo latente
independientes para cada persona.

</aside>


# Introducción

</br>

- Restricción dimensional

- Reducción de la sensibilidad dimensional del instrumento

- Indeterminación empírica

- "Ipdatividad" en puntuaciones de rasgo latente


<aside class="notes">

Esta condición constituye una indeterminación empírica que hemos denominado
"restricción dimensional", y consiste en una reducción de la
"sensibilidad dimensional" del instrumento, que en el caso
límite viene dada por la condición expresada en los
teoremas 1 y 2 del capítulo tercero.

En estas condiciones, lo que se observa es que las puntuaciones de rasgo latente
obtenidas mediante TRI tienen las mismas propiedades que las puntuaciones
ipsativas, y por lo tanto conviene evitar esta indeterminación ya que no
estaríamos solucionando los problemas de la ipsatividad.

</aside>


# Objetivos

- Estudiar la estimación del modelo MUPP-2PL en condiciones de restricción
dimensional

- Proponer y probar indicadores para evaluar la calidad del instrumento en
condiciones de restricción dimensional


# Estudio de simulación

```{r study_2_simulation_results, include=FALSE}
```

<center>
Resultados: Fiabilidad empírica

```{r simulation_reliability, fig.height=4, fig.width=9, dependson="study_2_simulation_results", cache=FALSE}

rel_results <- study_2_results %>%
  filter(Variable == "BSC x LTC") %>% 
  rename(`Fiabilidad media` = Valor) %>%
  mutate(
    `Correlación entre escalas` = c("-.7" %>% rep(3), "0" %>% rep(3), ".7" %>%
                                      rep(3)) %>% factor(levels = unique(.)),
    `Correlación entre dimensiones` = c(".00", ".25", ".50") %>% rep(3) %>%
      factor(levels = unique(.))
  )

rel_plot <- rel_results %>%
  ggplot(
    aes(
      `Correlación entre escalas`, `Fiabilidad media`,
      group = `Correlación entre dimensiones`, color = `Correlación entre dimensiones`
    )
  ) +
  geom_point() + geom_line()

rel_plot %>% ggplotly(tooltip = c("y", "colour")) %>% plotly_conf

```
</center>


<aside class="notes">

Al poner a prueba cómo afecta la indeterminación empírica a la fiabilidad
mediante un estudio de simulación, vemos que ésta decrece considerablemente
cuanto más nos aproximamos a la indeterminación empírica.

Además, este efecto interactúa con la correlación entre las dimensiones
latentes, siendo más acusado cuanto más correlacionadas están las dimensiones.

</aside>


# Estudio de simulación

<center>
Resultados: Distorsión de correlaciones

```{r simulation_corr_distortion, fig.height=4, fig.width=9, dependson="study_2_simulation_results", cache=FALSE}

diff_corr_results <- study_2_results %>%
  filter(Estadistico == "Dif. correlaciones") %>% 
  rename(`Distorión correlaciones` = Valor)

scales_plot <- diff_corr_results %>% filter(Variable %in% "Corr. escalas") %>%
  mutate(Nivel = Nivel %>% factor(levels = unique(.))) %>%
  rename(`Correlación entre escalas` = Nivel) %>%
  ggplot(
    aes(
      `Correlación entre escalas`, `Distorión correlaciones`,
      group = Variable
    )
  ) +
  geom_point(color = PALETTE.COLORS[1]) + geom_line(color = PALETTE.COLORS[1]) + ylim(-.35, 0) + ylab("Distorsión correlación") +
  xlab("Correlación entre escalas")

scales_plot %<>% ggplotly(tooltip = c("y", "colour"))

corrs_plot <- diff_corr_results %>% filter(Variable %in% "Corr. dimensiones") %>%
  mutate(Nivel = Nivel %>% factor(levels = unique(.))) %>%
  rename(`Correlaciones entre dimensiones` = Nivel) %>%
  ggplot(
    aes(
      `Correlaciones entre dimensiones`, `Distorión correlaciones`,
      group = Variable
    )
  ) +
  geom_point(color = PALETTE.COLORS[2]) + geom_line(color = PALETTE.COLORS[2]) + ylim(-.35, 0) +
  xlab("Correlación entre dimensiones")

corrs_plot %<>% ggplotly(tooltip = c("y", "colour"))

## TODO: etiquetar y fijar eje
subplot(nrows = 1, scales_plot, corrs_plot, shareY = TRUE) %>%
  plotly_conf %>% layout(margin = list(t = 40))

```
</center>


<aside class="notes">

La distancia respecto de la indeterminación empírica afecta también a cómo de
distorsionadas están las correlaciones entre los estimadores puntuales de
rasgo latente de las personas.

Sin embargo, al contrario que en la fiabilidad, esta distorsión es menos acusada
cuanto más correlacionadas están las dimensiones.

</aside>


# Evaluación de la sensibilidad dimensional

</br>

- _LSV_: "Least Singular Value"

- _LEV_: "Least eigenvalue"


<aside class="notes">

Para evaluar la sensibilidad dimensional hemos propuesto dos índices que
cuantifican la distancia desde la matriz de escalas de los bloques a la
situación límite de indeterminación empírica, y se basan en su descomposición en
valores singulares (en el caso del menor valor singular) o en autovalores (en el
caso del menor autovalor).

Este segundo índice tiene la ventaja de que incorpora información de las
correlaciones del espacio latente.

</aside>


# Estudio 2: Discusión

- El modelo MUPP-2PL puede estar empíricamente indeterminado

- Índices de sensibilidad dimensional

- Generalizabilidad de resultados


# Estudio 3:<br>Comprobación del supuesto de invarianza del modelo MUPP-2PL

```{r data_load, include=FALSE}
```

```{r data_formatting, include=FALSE, dependson="data_load"}
```

```{r unidimensionality_assessment, include=FALSE, dependson="data_formatting"}
```

```{r LR_tests, include=FALSE, dependson="unidimensionality_assessment"}
```

```{r all_stats_table, include=FALSE, dependson="LR_tests"}
```


# Objetivos

- Comprobar el supuesto de invarianza de los parámetros del modelo MUPP-2PL

- Explorar los factores que potencialmente influyen en la violación del supuesto


# Supuesto de invarianza

MUPP-2PL:

$$
\textrm{P}_i\left(Y_{ij} = 1 | {\bf \unicode[Times]{x3B8}}\right) = \Phi_L\left(a_{i_1}\theta_{\tilde{i_1}j} - a_{i_2}\theta_{\tilde{i_2}j} + l_i\right)
$$

Ítem 1:

$$
\textrm{P}_{i_1}\left(X_{i_1j} = 1 | \theta_\tilde{i_1}\right) = \Phi_L\left(a_{i_1}^*\left(\theta_{\tilde{i_1}j} - b_{i_1}\right)\right)
$$

Ítem 2:

$$
\textrm{P}_{i_2}\left(X_{i_2j} = 1 | \theta_\tilde{i_2}\right) = \Phi_L\left(a_{i_2}^*\left(\theta_{\tilde{i_2}j} - b_{i_2}\right)\right)
$$


# Supuesto de invarianza

<br>

<center>

- $a_{i_1}^*\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\longrightarrow a_{i_1}$

<br>

- $a_{i_2}^*\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\longrightarrow a_{i_2}$

<br>

- $a_{i_2}^*b_{i_2}-a_{i_1}^*b_{i_1}\longrightarrow l_i$

</center>


# Supuesto de invarianza

### Con ítems de escala graduada (i.e. Likert):

<!-- TODO: [imagen umbrales Likert] -->

$$a_{i_2}^*b_{i_2k'}-a_{i_1}^*b_{i_1k'}\longrightarrow l_i$$


# Prueba de invarianza

- Test razón de verosimilitud de modelos anidados (por parámetro)

<!-- TODO: [Imagen de modelos CFA con parámetros libres / restringidos] -->


- Estadístico: $SB-\chi^2$ robusto estrictamente positivo [@satorra_ensuring_2010]


<aside class="notes">

Para calcular este estadístico y realizar el test de razón de verosimilitudes
es necesario estimación CFA (Mplus; no algoritmo MCMC)

</aside>


# Prueba de invarianza

### Conjunto de datos:

- Test de personalidad "Big Five"

- Respuestas de 695 - 396 estudiantes

- Ítems Likert y bloques EF

- Emparejamiento de rasgos balanceado

- Bloques homopolares y heteropolares


# Resultados

<center>
### Parámetros de escala

```{r joint_scatter_plot_scales_per_item_trait, dependson="all_stats_table", cache=FALSE}

scales.joint.collapsed %>% rename(`Block_code` = Block) %>%
  left_join(
    block.item.params.joint %>% select(`Block_code` = Block, Bloque)
  ) %>%
  mutate(Label = NI %>% if_else(Bloque, NA_character_)) %>%
  scales.scatter.plot(
    Trait, labels = Label,
    width = 6, height = 5.2, units = "in", dpi = "print"
  )

```
</center>


<aside class="notes">

Se cumple el supuesto de invarianza en casi todos los casos, menos en dos
parámetros.

Esto imposibilita el estudio de la invarianza a nivel de ítems y bloques

A nivel de cuestionario:

"Compresión" del rango
Desplazamiento del origen

</aside>


# Resultados

<center>
### Parámetros de posición

```{r joint_threshold_plot_per_block, dependson="all_stats_table", fig.width=9, cache=FALSE}

threshold_1 <- block.item.params.joint %>% plot_joint_threshold_per_block(
  `Intersección`, `Predicción umbral 1`
)
threshold_2 <- block.item.params.joint %>% plot_joint_threshold_per_block(
  `Intersección`, `Predicción umbral 2`
)
threshold_3 <- block.item.params.joint %>% plot_joint_threshold_per_block(
  `Intersección`, `Predicción umbral 3`
)
threshold_4 <- block.item.params.joint %>% plot_joint_threshold_per_block(
  `Intersección`, `Predicción umbral 4`
)

subplot(
  threshold_1, threshold_2, threshold_3, threshold_4,
  nrows = 1, shareX = TRUE, shareY = TRUE
)

```
</center>


- "Compresión" del rango

- "Desplazamiento" del origen


<aside class="notes">

Más violaciones de invarianza con la segunda categoría.

Cuarta categoría la que menos.
Posible "desplazamiento" del origen: sesgo negativo en bloques, o posible
sesgo positivo (aquiescencia) en ítems, controlado por bloques

</aside>


# Resultados

```{r intercepts_preprocessing, include=FALSE, dependson="all_stats_table"}
```


<center>
### Exploración de violación del supuesto (posición)


```{r non_invariant_intercepts_plot, dependson="intercepts_preprocessing", fig.width=9, cache=FALSE}

intercept.invariance.plot <- non.invariant.intercepts %>%
  ggplot(
    aes(Bloque, `Desviación intersección`, shape = `Rasgo 1`, color = `Rasgo 2`)
  ) +
  geom_point(size = 2.5) + scale_shape_manual(values = c(16, 17, 15, 18)) +
  scale_color_manual(values = PALETTE.COLORS %>% unname) +
  geom_hline(yintercept = 0) +
  facet_grid(
    `Threshold category` ~ `Polarity 2`,
    as.table = FALSE, scales = "free_x"
  ) +
  theme_minimal(base_family = "serif", base_size = 12) +
  ggtitle("Polaridad del bloque") +
  theme(plot.title = element_text(hjust = .5, size = 12))

# intercept.invariance.plot %>% ggsave(
#   filename = "non_invariant_intercepts_plot.png", plot = .,
#   width = 6.5, height = 8, units = "in", dpi = "print"
# )

intercept.invariance.plot %>% ggplotly %>% config(displayModeBar = FALSE)

```
</center>


<aside class="notes">

Los rasgos medidos por cada ítem pueden jugar un papel en la violación
de la invarianza: más violaciones en Neuroticismo (en segunda posición) y
Apertura (primera pos)

Polaridades no parecen afectar (pero su efecto no puede separarse entre
polaridad del ítem, y bloque, debido al diseño de bloques heteropolares)

Patrón consistente para diferentes polaridades de ítems y rasgos

</aside>


# Resultados

<center>
### Exploración de violación del supuesto (posición)


```{r non_invariant_intercepts_plot_4th_threshold, dependson="intercepts_preprocessing", fig.width=9, cache=FALSE}

intercept.invariance.plot.threshold.4 <- non.invariant.intercepts %>%
  filter(`Threshold category` == "Umbral 4") %>%
  ggplot(
    aes(Bloque, `Desviación intersección`, shape = `Rasgo 1`, color = `Rasgo 2`)
  ) +
  geom_point(size = 2.5) + scale_shape_manual(values = c(16, 17, 15, 18)) +
  scale_color_manual(values = PALETTE.COLORS %>% unname) +
  geom_hline(yintercept = 0) +
  facet_grid(. ~ `Polarity 2`, as.table = FALSE, scales = "free_x"
  ) +
  theme_minimal(base_family = "serif", base_size = 12) +
  ggtitle("Polaridad del bloque") +
  theme(plot.title = element_text(hjust = .5, size = 12))

intercept.invariance.plot.threshold.4 %>% ggplotly %>%
  config(displayModeBar = FALSE)

```
</center>


<aside class="notes">

Asumiendo que se da el efecto de escalamiento y desplazamiento del origen,
podemos centrarnos en la categoría 4, asumiendo que sus predicciones son más
precisas: por un lado, tenemos el menor número de violaciones de la invarianza,
y por otro, los errores de predicción positivos y negativos están igualmente
distribuidos, al contrario que en otras categorías.

En estas condiciones, podemos interpretar las violaciones de la
invarianza como violacions del supuesto de independencia a su vez, posiblemente
debido a una interacción de efectos entre rasgo y polaridad.
(Es decir, combinar determinados ítems con rasgos y polaridades específicas
podría afectar a la invarianza)

El signo del error de predicción está asociado con la polaridad y el rasgo
medido.

</aside>


# Conclusiones

- Metodología para poner a prueba el supuesto del modelo MUPP-2PL

- Cumplimiento general del supuesto de invarianza

- Consideraciones sobre las violaciones de la invarianza

    - Efecto de escalamiento
    
    - Efecto de desplazamiento de la posición
    
    - Violaciones de invarianza a nivel de bloque


<aside class="notes">

El cumplimiento del supuesto de invarianza permite contruir QEFs basándose
en las propiedades de ítems Likert precalibrados
(Reducción de costes, optimización de criterios)

Violaciones de invarianza pueden afectar a la información:

Efecto de escalamiento reduciría la información del QEF (pero predecible)

Umbral usado para la estimación; por otro lado, modelos que puedan dar cuenta
de este efecto (e.g. sesgo de aquiescencia en los ítems)

Hipótesis a comprobar sobre los bloques, mediante ítems/bloques experimentales
diseñados para inducir o mitigar las violaciones de invarianza

</aside>


# Conclusions


<aside class="notes">

We have discussed the three studies separately. Now we will discuss some
conclusions fro the results of the three studies and the relationships among
them.

</aside>


---

> 1 - A variant of the MUPP model [@stark_irt_2005] under a dominance
measurement assumption can be formulated and identified; it has been called the
MUPP-2PL model.

<br>

> 2 - When data represents responses to a multidimensional pairwise FC
questionnaire, both the MUPP-2PL and the TIRT model [@brown_item_2011] can be
applied. Under these conditions, the two models are quasi-equivalent.

<br>

> 3 - A Bayesian procedure for estimating structural and incidental parameters
jointly is feasible. The method is based on Markov-Chain Monte Carlo simulation,
and an implementation in R [@r_core_team_r:_2017] has been developed.
Despite its high computational intensiveness, it gives highly accurate results.
These results are satisfactory even under two allegedly unfavorable conditions:
without unidimensional blocks, and without blocks with different polarity
combinations (i.e., heteropolar blocks)


<aside class="notes">

This model is more parsimonious than the original MUPP model.
In addition, it may be more appropriate than the original when the latent
agreement to the items in a block is a monotonical function of the trait level.

Scaling factor aside, their parameters and estimation methods are
interchangeable with negligible consequences.

</aside>


---

> 4 - The new Bayesian estimation procedure outperforms the estimation method
proposed for the TIRT model, based on analysis of bivariate information through
confirmatory factor analysis [@brown_fitting_2012].
Particularly, it yields more accurate estimation errors for the incidental
parameters, a better estimation of the latent space correlational structure,
and more reasonable estimates when empirical information is scant.

<br>

> 5 - The direct bidimensional pairs (DBP) design for FC questionnaires,
intended to control for bias associated with response styles,
may suffer from an empirical underidentification we may call
*dimensional restriction*.
This condition necessarily leads to (a) a notable reduction of the reliability,
and (b) distortion of the correlations among the latent trait estimates,
in the form of negative bias.


<aside class="notes">

Arguably,
the first result is due to the joint estimation of structural and incidental
parameters, the second to the use of full information, and the third to the
Bayesian features of the algorithm.

These properties are the same attributed to ipsative scores. Similar to them,
the distortion of the latent trait estimates will be worse the more positive the
actual latent dimension correlations are.

</aside>


---

> 6 - A FC instrument designed under the DBP principle, although not fulfilling
the conditions for the empirical underidentification, may be close enough to it
to have identification issues. We may refer to the distance of the instrument
information matrix to the empirical underidentification as its dimensional
sensitivity.

<br>

> 7 - We have proposed cutoff criteria for the *LSV* and *LEV*, useful to assess
the property of dimensional sensitivity of an instrument.
However, neither of these indices capture all the relevant phenomena related to
the dimensional restriction of a DBP FC instrument.

<aside class="notes">

This property can be quantified, and its magnitude estimated using two
proposed indices:
the least singular value (LSV), and the least eigenvalue (LEV).

Therefore, these indices should not be used for attempting to maximize the
dimensional sensitivity.

</aside>


---

> 8 - The invariance assumption of the MUPP-2PL model can be tested using a nested
model comparison method.

<br>

> 9 - This method has provided evidence in favor of the invariance assumption of
the MUPP-2PL model parameters.

<br>

> 10 - The item scale estimates especially fulfill the invariance assumption.
Therefore, their predictions can be used to estimate the dimensional sensitivity
of a pairwise multidimensional FC instrument using the *LSV* and *LEV*,
attending to its item pairings.

<br>

> 11 - The violations of the invariance assumption seem to follow at least
partially predictable patterns.


<aside class="notes">

We have showcased the Likelihood Ratio test applied to
the dataset of empirical responses to a FC questionnaire measuring
the Big-Five personality model.

Therefore, estimates from the graded responSe model, applied to a
graded-scale instrument made up by the individual items of the FCQ, may yield
accurate predictions of the MUPP-2PL model parameters.



Global translation and/or scaling transformations may affect the whole FC
format, while individual block parameters may deviate from their predictions due
to factors such as item dimensions or polarities.

</aside>


## Limitations

Regarding the model and its applications:

- Theoretical develovments only applicable to *pairwise* responses

- Pending issues regarding robustness against *motivated distortion*

- Underidentification of the item location parameters

- Invariance assumption with DBP design


<aside class="notes">

Relevant because:
This format is widely popular and is used in many instruments
Lay the foundations for future theoretical developments on other formats with
more than two items
Consider generatlizations due to connections to the TIRT and MUPP models.

DBP design not sufficient condition:
Pairing the items according to their *preference indices*
Impact of the pairing strategies on model properties
Invariance under different conditions (test only with straight-take conditions)

Major restraint for deisgn mulditidemsnional FC CATs.
Fulfilment of the invariance assumption is a necessary condition for using
pre-calibrated items.  Need to know pairing conditions to avoid.

Dimensional restriction of an instrument does not imply a distortion in the
structural parameter estimates.
If the underidentification is local to incidental parameters,
it may be possible that block parameters can be still accurately recovered.

</aside>


## Limitations

Regarding the Bayesian estimation procedure:

- No model fit indices introduced

- High technical skill required

- Intensive consumption of computational resources

    - Optimization strategies

- More general modeling framework (e.g. allowing restrictions and model nesting)


## Contributions

Related to the Ph.D. project:

- Three co-authored papers (one as leading)

- Two working papers in preparation (one as leading)

- Six communications in international conferences (two as speaker)

- Five communications in national conferences and seminars (four as speaker)

- Code for simulations and MCMC estimator (more than 7,600 lines of code)

- Several posters in national and international conferences


## Contributions

Aside from Ph.D. project:

- Five co-authored papers as collaborations (one as senior)

- Seven communications in national and international conferences (one as speaker)

- Several posters in national and international conferences


# Bibliografía seleccionada {.small}
